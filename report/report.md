# 双目成像实验报告

## 封面

g。自己先在word里做一张，包括分工：

曾富楠：40%，程序框架和最小生成树聚合
宣思诚：30%，NCC计算及双边滤波聚合
李泽奇：30%，双目校正和偏差值优化

## 问题描述

g。程序的大体框架，参考PPT/论文/代码。

## 实现细节

### 双目标定和校正

g。

### 输入输出

z。

### NCC计算

x。

### 双边滤波

x。

### 最小生成树聚合

最小生成树聚合是论文A non-local cost aggregation method for stereo matching中使用的一种类似双边滤波的聚合计算方法。这个方法的特点利用的数据结构比较复杂，但计算量很小，且表现不错，适合于CPU上进行计算。

#### 数学模型

作为一种基于生成树的图像滤波，最小生成树首先要求将像素点间的连通关系转换为生成树（spanning tree）的结构，即把图片中的像素和上下左右的相邻像素连接作为无向图，去掉若干边后，使得任意两个像素间只有一条可能的路径，且所有权重的合最小。

可以使用Prim算法计算最小生成树。按权重从小到大遍历所有边，遍历过程中，如果一条边的两端不在同一树中，则将这条边两端连接，加入生成树中，并且这条边在第二步不再遍历。对于RGB图片，权重指的是两个像素间RGB三个值的偏差中最大的一个，取值范围$[0,255]$。

构成生成树后，ST算法在全图上计算一个聚合的值：

$$
C^A(p) = \sum_{q\in I}{S(p, q)C(q)}
$$

其中$C^A(p)$为p点聚合后的cost，$C(q)$为q点聚合前的cost，$I$为图片上所有像素的集合，$S(p, q)$是图上这两个点的距离的函数，定义为

$$
S(p,q)=\exp{\left(-\frac{D(p,q)}{\sigma}\right)}
$$

$D(p,q)$为p、q两点间的距离，以生成树上这两间边的权重的和衡量。

若任意指定一个点为根节点，把生成树转换为有方向的树，则上述$C^A(p)$有一个计算量很小且递归的计算方法。定义$C^{A\uparrow}(p)=\sum_{q\in\operatorname{subtree}(p)}{S(p, q)C(q)}$为p点的子树中所有点对p点的聚合值的贡献，由于当b点在a、c两点间时，$S(a,c)=S(a,b)\cdot S(b,c)$，有方程

$$
\begin{align}
    C^{A\uparrow}(p) &= C(p) + \sum_{q\in\operatorname{child}(p)}{S(p,q)C^{A\uparrow}(q)}\\
    C^A(p) &= S(\operatorname{parent}(p),p)C^A(\operatorname{parent}(p))+(1-S(\operatorname{parent}(p),p)^2)C^{A\uparrow}(p)
\end{align}
$$

根据边界条件，p为叶节点时$C^{A\uparrow}(p)=C(p)$，可以递归地自底向上计算出各节点的$C^{A\uparrow}$，又有p为根节点时$C^A(p)=C^{A\uparrow}(p)$，可以递归地自顶向下计算出各节点的$C^A$。

#### 有向图的编码

实现上述算法重点是需要在图这样一个连接比较稀疏的结构中简单地表示边和节点，以及如何判断两个节点是否已连接。其余的过程按照Prim算法即可，生成完后再将无向图转换为有向图。

为了节约空间及更好的空间连续性可能带来的缓存性能优化，边用32位的位域表示，其中最高的8位表示权重，次高位表示是边的方向是横向还是纵向，其余的23位用于表示地址较小的像素的偏移地址，23位范围内大约可以表示4K，即3840x2160，足以满足实验的要求。权重直接嵌入到边的数据结构中，这样每次判断时不需要再去查找原图像，提高性能。

而无向图通过一个4位整数表示，四个比特分别表示上下左右四个方向上是否有相邻的边。树还需要一个额外的整数用于指示父节点的方向避免死循环，因此另有2个比特用于表示方向。

另外，判断两个点是否已连接需要使用到并查集。由于像素的偏移坐标是连续的，因此可以使用数组直接存储并查集的父节点。由于涉及非常多的查询操作，并查集只使用简单的路径压缩进行优化也可以保证性能。路径压缩即每次查找时，把查询路径上所有节点的父节点都指向最终的父节点，使得下次查询时一步即可到达。

有了上述数据结构，可以使用Prim算法计算最小生成树了：

1. 生成所有的边，即除了最右的像素都生成向右的一条边，除了最下的像素都生成向下的一条边
2. 根据权重排序这些边。由于权重的访问是完全独立的，通过`std::executaion::par_unseq`说明使用可以并行化的`std::sort`进行排序。
3. 计算最小生成树。根据权重从小到大遍历各边，通过并查集判断遍历到的边是否连接两个未连通的节点，如果是则更新无向图，把这个节点加入无向图中，同时也更新并查集反应无向图的连通状况。
4. 将最小生成树改为有向图，即任意指定一节点为根节点，深度优先遍历各节点，确定父节点的方向。

#### 聚合

建立了树之后，聚合是比较简单的，只需要根据4个方向，从根节点开始逐个遍历所有的节点，首先计算$C^{A\uparrow}($，然后再计算$C^A$即可。但需要注意的是，由于遍历的深度可能非常非常深，不能使用系统栈，而是需要手动地编写状态机，这是比较复杂的，尤其是自底向上遍历时，还需要涉及复杂的状态储存。

但需要关注的是聚合过程中的数值稳定性。在$C^A(p) = S(\operatorname{parent}(p),p)C^A(\operatorname{parent}(p))+(1-S(\operatorname{parent}(p),p)^2)C^{A\uparrow}(p)$中，$C^A(\operatorname{parent}(p))$已经包含了$C^{A\uparrow}(p)$，在后面的计算中又减去$C^{A\uparrow}(p)$，由于浮点数的取整，左右并不严格相等。但这里实际上表现为两个正数相加，即使有浮点误差影响也不大。但要注意的是，如果cost可能是nan，则会导致整个树都是nan，这是全局滤波不可避免的。

### 偏差值优化

g。refine_disparity和choose_disparity

### 性能优化

双目成像是计算量非常大的任务，在未经优化的代码上，一幅图片可能需要数分钟的时间。因此，实验中还进行了性能优化的尝试：

#### 使用适合CPU的算法

由于我们选用CPU进行计算，因此要充分选择发挥CPU顺序执行能力的算法。在NCC计算部分，我们使用了前缀和，使得求和部分的计算量和求和区域大小无关。在聚合部分，我们使用了基于图的聚合方法，这个方法对内存的要求非常高，也包含大量分支，是比较适合CPU的计算能力的。

#### 并行计算

实验中各个环节都涉及大量数值计算，这些计算都跟偏差值d关系不大，因此我们在所有遍历d的循环上都使用OMP进行了并行，充分利用CPU的多个核心。

#### 充分内联

在实验中我们发现，访问图像某一位置值的函数`Mat::at`并没有被内联，这使得大量的循环优化等没有实现。通过调整MSVC内联级别从`/O2`默认的`/Ob2`到更强的`/Ob3`，可以发现`Mat::at`被内联，使得程序速度提高了20%左右。

## 实验结果

### Middlebury 2021表现

### 自制数据集表现

## 应用背景分析或展望

